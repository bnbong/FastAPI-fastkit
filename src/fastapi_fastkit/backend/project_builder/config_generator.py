# --------------------------------------------------------------------------
# Dynamic configuration file generation based on user selections
#
# Generates:
# - main.py with selected features
# - Database configuration files
# - Authentication setup files
# - Docker files
# - Testing configuration
#
# @author bnbong bbbong9@gmail.com
# --------------------------------------------------------------------------
import os
from pathlib import Path
from typing import Any, Dict, List, Optional


class DynamicConfigGenerator:
    """
    Generates configuration files based on project config.

    This class generates various configuration and setup files
    dynamically based on the user's feature selections.
    """

    def __init__(self, config: Dict[str, Any], project_dir: str) -> None:
        """
        Initialize config generator.

        Args:
            config: Project configuration dictionary
            project_dir: Path to the project directory
        """
        self.config = config
        self.project_dir = Path(project_dir)

    @staticmethod
    def _build_header(title: str) -> list[str]:
        """
        Build a standard FastAPI-fastkit header comment.

        Args:
            title: Title of the file

        Returns:
            List of header lines
        """
        return [
            "# --------------------------------------------------------------------------",
            f"# {title}",
            "# Generated by FastAPI-fastkit",
            "# --------------------------------------------------------------------------",
        ]

    @staticmethod
    def _join_lines(lines: list[str]) -> str:
        """
        Join lines with newline and ensure proper ending.

        Args:
            lines: List of code lines

        Returns:
            Joined string with newlines
        """
        return "\n".join(lines) + "\n"

    @staticmethod
    def _build_code_block(indent: str, *lines: str) -> list[str]:
        """
        Build a code block with consistent indentation.

        Args:
            indent: Indentation string (e.g., "    " for 4 spaces)
            lines: Lines of code to indent

        Returns:
            List of indented lines
        """
        return [f"{indent}{line}" if line else "" for line in lines]

    def generate_all_files(self) -> None:
        """Generate all configuration files."""
        # This method will be called by the main CLI
        # Individual file generation will be handled by specific methods
        pass

    def generate_main_py(self) -> str:
        """
        Generate main.py with selected features.

        Returns:
            Content of main.py as string
        """
        imports = []
        app_config = []
        startup_code = []
        middleware_code = []
        route_includes: List[str] = []

        # Base imports
        imports.append("from fastapi import FastAPI")
        imports.append("from fastapi.middleware.cors import CORSMiddleware")

        # Database imports
        db_type = self.config.get("database", {}).get("type", "None")
        if db_type in ["PostgreSQL", "MySQL", "SQLite"]:
            imports.append(
                "from sqlalchemy.ext.asyncio import create_async_engine, AsyncSession"
            )
            imports.append("from sqlalchemy.orm import sessionmaker")
            startup_code.append("    # Initialize database")
            startup_code.append("    # await init_db()")
        elif db_type == "MongoDB":
            imports.append("from motor.motor_asyncio import AsyncIOMotorClient")
            startup_code.append("    # Initialize MongoDB")
            startup_code.append(
                "    # client = AsyncIOMotorClient(settings.MONGODB_URL)"
            )

        # Authentication imports
        auth_type = self.config.get("authentication", "None")
        if auth_type == "JWT":
            imports.append("from fastapi.security import HTTPBearer")
        elif auth_type == "FastAPI-Users":
            imports.append("# FastAPI-Users setup will be in separate auth module")

        # CORS configuration
        utilities = self.config.get("utilities", [])
        if "CORS" in utilities:
            middleware_code.append("# CORS middleware")
            middleware_code.append("app.add_middleware(")
            middleware_code.append("    CORSMiddleware,")
            middleware_code.append(
                "    allow_origins=['*'],  # Configure appropriately"
            )
            middleware_code.append("    allow_credentials=True,")
            middleware_code.append("    allow_methods=['*'],")
            middleware_code.append("    allow_headers=['*'],")
            middleware_code.append(")")

        # Rate limiting
        if "Rate-Limiting" in utilities:
            imports.append("from slowapi import Limiter, _rate_limit_exceeded_handler")
            imports.append("from slowapi.util import get_remote_address")
            imports.append("from slowapi.errors import RateLimitExceeded")
            app_config.append("limiter = Limiter(key_func=get_remote_address)")
            app_config.append("app.state.limiter = limiter")
            app_config.append(
                "app.add_exception_handler(RateLimitExceeded, _rate_limit_exceeded_handler)"
            )

        # Monitoring
        monitoring_type = self.config.get("monitoring", "None")
        if monitoring_type == "Loguru":
            imports.append("from loguru import logger")
        elif monitoring_type == "Prometheus":
            imports.append(
                "from prometheus_fastapi_instrumentator import Instrumentator"
            )
            startup_code.append("    # Initialize Prometheus metrics")
            startup_code.append("    Instrumentator().instrument(app).expose(app)")

        # Build main.py content
        content_parts = []

        # Imports section
        content_parts.append(
            "# --------------------------------------------------------------------------"
        )
        content_parts.append("# FastAPI Application Main Entry Point")
        content_parts.append("# Generated by FastAPI-fastkit")
        content_parts.append(
            "# --------------------------------------------------------------------------"
        )
        content_parts.extend(imports)
        content_parts.append("")

        # App initialization
        project_name = self.config.get("project_name", "FastAPI App")
        description = self.config.get("description", "")
        content_parts.append(f"app = FastAPI(")
        content_parts.append(f'    title="{project_name}",')
        content_parts.append(f'    description="{description}",')
        content_parts.append(f'    version="0.1.0",')
        content_parts.append(f")")
        content_parts.append("")

        # App configuration
        if app_config:
            content_parts.extend(app_config)
            content_parts.append("")

        # Middleware
        if middleware_code:
            content_parts.extend(middleware_code)
            content_parts.append("")

        # Startup event
        if startup_code:
            content_parts.append("@app.on_event('startup')")
            content_parts.append("async def startup_event():")
            content_parts.extend(startup_code)
            content_parts.append("")

        # Basic health check endpoint
        content_parts.append("@app.get('/', tags=['Health'])")
        content_parts.append("async def root():")
        content_parts.append("    return {")
        content_parts.append(f"        'message': 'Welcome to {project_name}',")
        content_parts.append("        'status': 'healthy',")
        content_parts.append("    }")
        content_parts.append("")

        content_parts.append("@app.get('/health', tags=['Health'])")
        content_parts.append("async def health_check():")
        content_parts.append("    return {'status': 'ok'}")
        content_parts.append("")

        # Route includes (placeholder)
        if route_includes:
            content_parts.extend(route_includes)
            content_parts.append("")

        return "\n".join(content_parts)

    def generate_database_config(self) -> Optional[str]:
        """
        Generate database configuration.

        Returns:
            Content of database config file or None
        """
        db_type = self.config.get("database", {}).get("type", "None")

        if db_type == "None":
            return None

        if db_type in ["PostgreSQL", "MySQL", "SQLite"]:
            return self._generate_sqlalchemy_config(db_type)
        elif db_type == "MongoDB":
            return self._generate_mongodb_config()

        return None

    def _generate_sqlalchemy_config(self, db_type: str) -> str:
        """Generate SQLAlchemy database configuration."""
        content = []
        content.append(
            "# --------------------------------------------------------------------------"
        )
        content.append("# Database Configuration")
        content.append("# Generated by FastAPI-fastkit")
        content.append(
            "# --------------------------------------------------------------------------"
        )
        content.append(
            "from sqlalchemy.ext.asyncio import create_async_engine, AsyncSession"
        )
        content.append("from sqlalchemy.orm import sessionmaker, declarative_base")
        content.append("from pydantic_settings import BaseSettings")
        content.append("")
        content.append("class DatabaseSettings(BaseSettings):")
        content.append('    """Database configuration settings."""')

        if db_type == "PostgreSQL":
            content.append(
                "    DATABASE_URL: str = 'postgresql+asyncpg://user:password@localhost/dbname'"
            )
        elif db_type == "MySQL":
            content.append(
                "    DATABASE_URL: str = 'mysql+aiomysql://user:password@localhost/dbname'"
            )
        elif db_type == "SQLite":
            content.append("    DATABASE_URL: str = 'sqlite+aiosqlite:///./app.db'")

        content.append("")
        content.append("    class Config:")
        content.append("        env_file = '.env'")
        content.append("")
        content.append("settings = DatabaseSettings()")
        content.append("")
        content.append("# Create async engine")
        content.append("engine = create_async_engine(")
        content.append("    settings.DATABASE_URL,")
        content.append("    echo=True,")
        content.append("    future=True,")
        content.append(")")
        content.append("")
        content.append("# Create async session factory")
        content.append("AsyncSessionLocal = sessionmaker(")
        content.append("    engine,")
        content.append("    class_=AsyncSession,")
        content.append("    expire_on_commit=False,")
        content.append(")")
        content.append("")
        content.append("# Create base class for models")
        content.append("Base = declarative_base()")
        content.append("")
        content.append("async def get_db():")
        content.append('    """Dependency for getting async database session."""')
        content.append("    async with AsyncSessionLocal() as session:")
        content.append("        try:")
        content.append("            yield session")
        content.append("            await session.commit()")
        content.append("        except Exception:")
        content.append("            await session.rollback()")
        content.append("            raise")
        content.append("")

        return "\n".join(content)

    def _generate_mongodb_config(self) -> str:
        """Generate MongoDB configuration."""
        content = []
        content.append(
            "# --------------------------------------------------------------------------"
        )
        content.append("# MongoDB Configuration")
        content.append("# Generated by FastAPI-fastkit")
        content.append(
            "# --------------------------------------------------------------------------"
        )
        content.append("from motor.motor_asyncio import AsyncIOMotorClient")
        content.append("from pydantic_settings import BaseSettings")
        content.append("")
        content.append("class DatabaseSettings(BaseSettings):")
        content.append('    """MongoDB configuration settings."""')
        content.append("    MONGODB_URL: str = 'mongodb://localhost:27017'")
        content.append("    MONGODB_DB_NAME: str = 'fastapi_db'")
        content.append("")
        content.append("    class Config:")
        content.append("        env_file = '.env'")
        content.append("")
        content.append("settings = DatabaseSettings()")
        content.append("")
        content.append("# MongoDB client")
        content.append("client = AsyncIOMotorClient(settings.MONGODB_URL)")
        content.append("database = client[settings.MONGODB_DB_NAME]")
        content.append("")

        return "\n".join(content)

    def generate_auth_config(self) -> Optional[str]:
        """
        Generate authentication configuration.

        Returns:
            Content of auth config file or None
        """
        auth_type = self.config.get("authentication", "None")

        if auth_type == "None":
            return None

        if auth_type == "JWT":
            return self._generate_jwt_config()
        elif auth_type == "FastAPI-Users":
            return self._generate_fastapi_users_config()

        return None

    def _generate_jwt_config(self) -> str:
        """Generate JWT authentication configuration."""
        content = []
        content.append(
            "# --------------------------------------------------------------------------"
        )
        content.append("# JWT Authentication Configuration")
        content.append("# Generated by FastAPI-fastkit")
        content.append(
            "# --------------------------------------------------------------------------"
        )
        content.append("from datetime import datetime, timedelta")
        content.append("from typing import Optional")
        content.append("from jose import JWTError, jwt")
        content.append("from passlib.context import CryptContext")
        content.append("from pydantic_settings import BaseSettings")
        content.append("")
        content.append("class AuthSettings(BaseSettings):")
        content.append('    """Authentication configuration settings."""')
        content.append(
            "    SECRET_KEY: str = 'your-secret-key-here-change-in-production'"
        )
        content.append("    ALGORITHM: str = 'HS256'")
        content.append("    ACCESS_TOKEN_EXPIRE_MINUTES: int = 30")
        content.append("")
        content.append("    class Config:")
        content.append("        env_file = '.env'")
        content.append("")
        content.append("settings = AuthSettings()")
        content.append("")
        content.append("# Password hashing")
        content.append(
            "pwd_context = CryptContext(schemes=['bcrypt'], deprecated='auto')"
        )
        content.append("")
        content.append(
            "def verify_password(plain_password: str, hashed_password: str) -> bool:"
        )
        content.append('    """Verify a password against a hash."""')
        content.append("    return pwd_context.verify(plain_password, hashed_password)")
        content.append("")
        content.append("def get_password_hash(password: str) -> str:")
        content.append('    """Hash a password."""')
        content.append("    return pwd_context.hash(password)")
        content.append("")
        content.append(
            "def create_access_token(data: dict, expires_delta: Optional[timedelta] = None) -> str:"
        )
        content.append('    """Create JWT access token."""')
        content.append("    to_encode = data.copy()")
        content.append("    if expires_delta:")
        content.append("        expire = datetime.utcnow() + expires_delta")
        content.append("    else:")
        content.append(
            "        expire = datetime.utcnow() + timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES)"
        )
        content.append("    to_encode.update({'exp': expire})")
        content.append(
            "    encoded_jwt = jwt.encode(to_encode, settings.SECRET_KEY, algorithm=settings.ALGORITHM)"
        )
        content.append("    return encoded_jwt")
        content.append("")

        return "\n".join(content)

    def _generate_fastapi_users_config(self) -> str:
        """Generate FastAPI-Users configuration."""
        content = []
        content.append(
            "# --------------------------------------------------------------------------"
        )
        content.append("# FastAPI-Users Authentication Configuration")
        content.append("# Generated by FastAPI-fastkit")
        content.append("#")
        content.append("# For full setup guide, visit:")
        content.append("# https://fastapi-users.github.io/fastapi-users/")
        content.append(
            "# --------------------------------------------------------------------------"
        )
        content.append("# TODO: Implement FastAPI-Users setup")
        content.append(
            "# This requires database models, user manager, and auth backends"
        )
        content.append("# See the official documentation for complete setup")
        content.append("")

        return "\n".join(content)

    def generate_docker_files(self) -> None:
        """Generate Dockerfile and docker-compose.yml."""
        deployment = self.config.get("deployment", [])

        if "Docker" in deployment:
            dockerfile_content = self._generate_dockerfile()
            dockerfile_path = self.project_dir / "Dockerfile"
            with open(dockerfile_path, "w") as f:
                f.write(dockerfile_content)

        if "docker-compose" in deployment:
            compose_content = self._generate_docker_compose()
            compose_path = self.project_dir / "docker-compose.yml"
            with open(compose_path, "w") as f:
                f.write(compose_content)

    def _generate_dockerfile(self) -> str:
        """Generate Dockerfile content."""
        content = []
        content.append(
            "# --------------------------------------------------------------------------"
        )
        content.append("# Dockerfile")
        content.append("# Generated by FastAPI-fastkit")
        content.append(
            "# --------------------------------------------------------------------------"
        )
        content.append("FROM python:3.11-slim")
        content.append("")
        content.append("WORKDIR /app")
        content.append("")
        content.append("# Install dependencies")
        content.append("COPY requirements.txt .")
        content.append("RUN pip install --no-cache-dir -r requirements.txt")
        content.append("")
        content.append("# Copy application")
        content.append("COPY . .")
        content.append("")
        content.append("# Run application")
        content.append(
            "CMD ['uvicorn', 'src.main:app', '--host', '0.0.0.0', '--port', '8000']"
        )
        content.append("")

        return "\n".join(content)

    def _generate_docker_compose(self) -> str:
        """Generate docker-compose.yml content."""
        content = []
        content.append(
            "# --------------------------------------------------------------------------"
        )
        content.append("# docker-compose.yml")
        content.append("# Generated by FastAPI-fastkit")
        content.append(
            "# --------------------------------------------------------------------------"
        )
        content.append("version: '3.8'")
        content.append("")
        content.append("services:")
        content.append("  app:")
        content.append("    build: .")
        content.append("    ports:")
        content.append("      - '8000:8000'")
        content.append("    environment:")
        content.append("      - DATABASE_URL=${DATABASE_URL}")
        content.append("    depends_on:")

        db_type = self.config.get("database", {}).get("type", "None")
        if db_type == "PostgreSQL":
            content.append("      - db")
            content.append("")
            content.append("  db:")
            content.append("    image: postgres:15")
            content.append("    environment:")
            content.append("      - POSTGRES_USER=user")
            content.append("      - POSTGRES_PASSWORD=password")
            content.append("      - POSTGRES_DB=dbname")
            content.append("    ports:")
            content.append("      - '5432:5432'")
            content.append("    volumes:")
            content.append("      - postgres_data:/var/lib/postgresql/data")
            content.append("")
            content.append("volumes:")
            content.append("  postgres_data:")
        elif db_type == "MongoDB":
            content.append("      - mongodb")
            content.append("")
            content.append("  mongodb:")
            content.append("    image: mongo:6")
            content.append("    ports:")
            content.append("      - '27017:27017'")
            content.append("    volumes:")
            content.append("      - mongo_data:/data/db")
            content.append("")
            content.append("volumes:")
            content.append("  mongo_data:")
        else:
            content.append("      # Add database service if needed")

        content.append("")

        return "\n".join(content)

    def generate_test_config(self) -> Optional[str]:
        """
        Generate pytest configuration.

        Returns:
            Content of pytest.ini or None
        """
        testing_type = self.config.get("testing", "None")

        if testing_type == "None":
            return None

        content = []
        content.append(
            "# --------------------------------------------------------------------------"
        )
        content.append("# pytest configuration")
        content.append("# Generated by FastAPI-fastkit")
        content.append(
            "# --------------------------------------------------------------------------"
        )
        content.append("[pytest]")
        content.append("testpaths = tests")
        content.append("python_files = test_*.py")
        content.append("python_classes = Test*")
        content.append("python_functions = test_*")
        content.append("asyncio_mode = auto")

        if "Coverage" in testing_type or "Advanced" in testing_type:
            content.append("")
            content.append("[coverage:run]")
            content.append("source = .")
            content.append("omit = ")
            content.append("    tests/*")
            content.append("    .venv/*")
            content.append("    */__pycache__/*")

        content.append("")

        return "\n".join(content)
